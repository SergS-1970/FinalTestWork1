# **Итоговая проверочная работа.**

## **Условие задачи.**

*Задача* : Написать программу, которая из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна 3 символам. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

*Примеры:*
>[“Hello”, “2”, “world”, “:-)”] → [“2”, “:-)”]
>[“1234”, “1567”, “-2”, “computer science”] → [“-2”]
>[“Russia”, “Denmark”, “Kazan”] → []

## **Описание решения.**

### **Общие замечания.**
Задача решалась двумя способами:
* Короткий способ (*ShortVersion*);
* Основное решение (*BasicSolution*).

**Короткий способ** экономичен и позволяет решить задачу, используя всего лишь один цикл и одну вложенную в него операцию ветвления. Однако такое решение представляется мне не вполне корректным (обоснование этого - в разделе, описывающем решение задачи *"коротким способом"*).
**Основное решение** длиннее, но его корректность полностью подтверждается контрольными примерами.

### __Описание алгоритма решения *"коротким способом"*.__

Объявляем два массива строк (исходный *sourceArrayA* и итоговый *finalArrayF*) одинаковой длины *sizeA*. Создаём переменную для подсчёта коротких (3 и меньше символов) строк исходного массива *shortElementCounter* (начальное значение = 0). Данная переменная понадобится для заполнения итогового массива короткими элементами по порядку, начиная с нулевого индекса. Соответственно, все незаполненные элементы итогового массива окажутся в его конце.

Запускаем цикл ввода элементов исходного массива. Паралельно вводу проверяем длину этих элементов на предмет соответствия условию задачи ("длина меньше либо равна 3 символа").

**Если данное условие выполняется** для какого-либо элемента исходного массива *sourceArrayA[i]*:

    if (sourceArrayA[i].Length <= 3)
 заносим этот элемент в итоговый массив. При этом индекс соответствующего элемента итогового массива будет равен текущему значению счётчика *shortElementCounter*:

    finalArrayF[shortElementCounter] = sourceArrayA[i];
после чего увеличиваем значение счётчика на единицу:

    shortElementCounter++;
и переходим к следующему элементу исходного массива.

**Если условие не выполняется** (длина sourceArrayA[i] 4 и больше символов) - сразу переходим к следующему элементу исходного массива.

После завершения цикла - выводим исходный и итоговый массивы, используя оператор присоединения строк.

Блок-схема данного решения приведена в папке BlockDiagram (файлы *short version.drawio* и *ShortVersion.png*). Программный код  - файл *Program* в папке *short_version*.

**_Почему данный способ не вполне корректен?_**
При всей простоте реализации данный способ имеет один существенный недостаток по сравнению с приведённым ниже **_"основным решением"_**: итоговый массив равен по длине исходному массиву, следовательно содержит некоторое количество незаполненных элементов (их число будет равно числу элементов исходного массива с длиной 4 символа и более). А это не согласуется с контрольными примерами, в которых чётко видно, что __размер итогового массива всегда равен количеству элементов, длина которых меньше или равна 3-х символов__. Поэтому данное решение приведено только в качестве дополнительного.

### __Описание алгоритма *"основного решения"*.__

Объявляем исходный массив строк (*sourceArrayA*) с заданной длиной *sizeA*. Создаём переменную для подсчёта коротких (3 и меньше символов) строк исходного массива *shortElementCounter* (начальное значение = 0). Данная переменная требуется для определения длины итогового массива *finalArrayF*.

Запускаем цикл ввода элементов исходного массива. Паралельно вводу проверяем длину этих элементов на предмет соответствия условию задачи ("длина меньше либо равна 3 символа").

**Если данное условие выполняется** для какого-либо элемента исходного массива *sourceArrayA[i]*:

    if (sourceArrayA[i].Length <= 3)  
 увеличиваем значение счётчика на единицу:

    shortElementCounter++;
и переходим к следующему элементу исходного массива.

**Если условие не выполняется** (длина *sourceArrayA[i]* 4 и больше символов) - сразу переходим к следующему элементу исходного массива.

После завершения цикла объявляем итоговый массив *finalArrayF*, длина которого равна итоговому значению переменной *shortElementCounter* (т.е. числу элементов исходного массива, длина которых не превышает 3-х символов).

Создаём переменную, отвечающую за индекс элементов в итоговом массиве *j*. Начальное значение *j* = 0).

Запускаем цикл перебора элементов исходного массива. В цикле проверяем длину этих элементов на предмет соответствия условию задачи ("длина меньше либо равна 3 символа").

**Если данное условие выполняется** для какого-либо элемента исходного массива *sourceArrayA[i]*:

    if (sourceArrayA[i].Length <= 3)
 заносим этот элемент в итоговый массив. При этом индекс соответствующего элемента итогового массива будет равен текущему значению переменной **j**:

    finalArrayF[j] = sourceArrayA[i];
после чего увеличиваем значение индекса на единицу:
    
    j++;  
и переходим к проверке следующего элемента исходного массива.

**Если условие не выполняется** (длина *sourceArrayA[i]* 4 и больше символов) - сразу переходим к следующему элементу исходного массива.

После завершения цикла - выводим исходный и итоговый массивы, используя оператор присоединения строк.

Блок-схема данного решения приведена в папке BlockDiagram (файлы __*basic solution.drawio*__ и __*BasicSolution.png*__). Программный код  - файл __*Program*__ в папке __*basic_solution*__.
